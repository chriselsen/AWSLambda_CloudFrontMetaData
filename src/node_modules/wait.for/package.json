{
  "name": "wait.for",
  "version": "0.6.6",
  "description": "Sequential programming for node.js, end of callback hell",
  "author": {
    "name": "Lucio Tato",
    "email": "luciotato@gmail.com",
    "url": "http://github.com/luciotato"
  },
  "keywords": [
    "fiber",
    "fibers",
    "coroutine",
    "thread",
    "sync",
    "async",
    "parallel",
    "worker",
    "future",
    "promise",
    "wait",
    "Wait.for",
    "callback hell",
    "pyramid of doom"
  ],
  "homepage": "http://github.com/luciotato/waitfor",
  "license": "Creative Commons, MIT",
  "bugs": {
    "url": "http://github.com/luciotato/waitfor/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/luciotato/waitfor.git"
  },
  "main": "waitfor.js",
  "engines": {
    "node": ">=0.5.2"
  },
  "dependencies": {
    "fibers": ">=1.0.1"
  },
  "scripts": {
    "test": "node tests"
  },
  "readme": "Wait.for\n=======\nSequential programming for node.js, end of callback hell.\n\nSimple, straightforward abstraction over [Fibers](https://github.com/laverdet/node-fibers).\n\nBy using **wait.for**, you can call any nodejs standard async function in sequential/Sync mode, waiting for result data, \nwithout blocking node's event loop (thanks to fibers)\n\nA nodejs standard async function is a function in which the last parameter is a callback: function(err,data)\n\nAdvantages:\n* Avoid callback hell / pyramid of doom\n* Simpler, sequential programming when required, without blocking node's event loop (thanks to fibers)\n* Simpler, try-catch exception programming. (default callback handler is: if (err) throw err; else return data)\n* You can also launch multiple parallel non-concurrent fibers.\n* No multi-threaded debugging nightmares, only one fiber running at a given time (thanks to fibers)\n* Can use any node-standard async function with callback(err,data) as last parameter.\n* Plays along with node programming style. Write your async functions with callback(err,data), but use them in sequential/SYNC mode when required.\n* Plays along with node cluster. You design for one thread/processor, then scale with cluster on multicores.\n\n##NEWS\n\n----------------\n####March-2014 - LiteScript\n\nI've ported this functionality to [LiteScript](//github.com/luciotato/LiteScript).\n\nLiteScript is a  higly readable, compile to js language. LiteScript has type annotations, a compile-time validation phase, and catch common js errors and typos in object property names, speeding up development (you code faster) and saving hours of debugging over a mistyped property name. \n[Try LiteScript online](http://luciotato.github.io/LiteScript_online_playground/playground)\n\nHere it is a sample of LiteScript Code, showing \"yield until\" (wait for async to complete) and \"yield parallel\" (launch in parallel, wait until all asyncs complete)\n\n#####get google.com IPs, then reverse DNS (in parallel)\n    global import dns, nicegen\n    nice function resolveAndParallelReverse\n        try\n            var addresses:array = yield until dns.resolve \"google.com\"\n            var results = yield parallel map addresses dns.reverse \n            for each index,addr in addresses\n                print \"#{addr} reverse: #{results[index]}\"\n        catch err\n            print \"caught:\", err.stack\n    end nice function\n\n---------------\n###Aug-2013 - Wait.for-ES6 based on ES6-generators\n\nI've developed ***a version based on JavaScript upcoming ES6-Harmony generators***. It's not based on node-fibers.\n***Surprisingly***, ES6 based implementation of *wait.for(asyncFn)* is almost a no-op, you can even completely omit it. *Warning: Bleeding edge*. Check [Wait.for-ES6] (https://github.com/luciotato/waitfor-ES6) \n\n---------------\n\n\nInstall: \n----\n        npm install wait.for\n\n\nProper Use:\n----\nYou need to be in a Fiber to be able to use wait.for. The ideal place to launch a fiber\nis when a request arrives, to handle it:\n\n```javascript\nvar server = http.createServer(\n  function(req, res){\n    console.log('req!');\n    wait.launchFiber(handler,req,res); //handle in a fiber, keep node spinning\n  }).listen(8000);\n```\n\nthen,at *function handler(req,res)* and every function you call from there, \nyou'll be able to use wait.for(ayncFn...\n\nExamples:\n-\n\nDNS testing, *using pure node.js* (a little of callback hell):\n```javascript\nvar dns = require(\"dns\");\n    \nfunction test(){ \n\tdns.resolve4(\"google.com\", function(err, addresses) {\n\t\tif (err) throw err;\n\t\tfor (var i = 0; i < addresses.length; i++) {\n\t\t\tvar a = addresses[i];\n\t\t\tdns.reverse(a, function (err, data) {\n\t\t\t\tif (err) throw err;\n\t\t\t\tconsole.log(\"reverse for \" + a + \": \" + JSON.stringify(data));\n\t\t\t});\n\t\t};\n\t});\n}\n\ntest();\n```\n\n***THE SAME CODE***, using **wait.for** (sequential):\n```javascript\nvar dns = require(\"dns\"), wait=require('wait.for');\n\nfunction test(){\n\tvar addresses = wait.for(dns.resolve4,\"google.com\");\n\tfor (var i = 0; i < addresses.length; i++) {\n\t\tvar a = addresses[i];\n\t\tconsole.log(\"reverse for \" + a + \": \" + JSON.stringify(wait.for(dns.reverse,a)));\n\t}\n}\n\nwait.launchFiber(test); \n```\n\nDatabase example (pseudocode)\n--\n*using pure node.js* (a callback hell):\n```javascript\nvar db = require(\"some-db-abstraction\");\n\nfunction handleWithdrawal(req,res){  \n\ttry {\n\t\tvar amount=req.param(\"amount\");\n\t\tdb.select(\"* from sessions where session_id=?\",req.param(\"session_id\"),function(err,sessiondata) {\n\t\t\tif (err) throw err;\n\t\t\tdb.select(\"* from accounts where user_id=?\",sessiondata.user_ID),function(err,accountdata) {\n\t\t\t\tif (err) throw err;\n\t\t\t\t\tif (accountdata.balance < amount) throw new Error('insufficient funds');\n\t\t\t\t\tdb.execute(\"withdrawal(?,?)\",accountdata.ID,req.param(\"amount\"), function(err,data) {\n\t\t\t\t\t\tif (err) throw err;\n\t\t\t\t\t\tres.write(\"withdrawal OK, amount: \"+ req.param(\"amount\"));\n\t\t\t\t\t\tdb.select(\"balance from accounts where account_id=?\", accountdata.ID,function(err,balance) {\n\t\t\t\t\t\t\tif (err) throw err;\n\t\t\t\t\t\t\tres.end(\"your current balance is \"  + balance.amount);\n\t\t\t\t\t\t});\n    \t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tcatch(err) {\n\t\t\tres.end(\"Withdrawal error: \"  + err.message);\n\t}\n}\n```\nNote: The above code, although it looks like it will catch the exceptions, **it will not**. \nCatching exceptions with callback hell adds a lot of pain, and i'm not sure if you will have the 'res' parameter \nto respond to the user. If somebody like to fix this example... be my guest.\n\n\n***THE SAME CODE***, using **wait.for** (sequential logic - sequential programming):\n```javascript\nvar db = require(\"some-db-abstraction\"), wait=require('wait.for');\n\nfunction handleWithdrawal(req,res){  \n\ttry {\n\t\tvar amount=req.param(\"amount\");\n\t\tsessiondata = wait.forMethod(db,\"select\",\"* from session where session_id=?\",req.param(\"session_id\"));\n\t\taccountdata = wait.forMethod(db,\"select\",\"* from accounts where user_id=?\",sessiondata.user_ID);\n\t\tif (accountdata.balance < amount) throw new Error('insufficient funds');\n\t\twait.forMethod(db,\"execute\",\"withdrawal(?,?)\",accountdata.ID,req.param(\"amount\"));\n\t\tres.write(\"withdrawal OK, amount: \"+ req.param(\"amount\"));\n\t\tbalance = wait.forMethod(db,\"select\",\"balance from accounts where account_id=?\", accountdata.ID);\n\t\tres.end(\"your current balance is \"  + balance.amount);\n\t\t}\n\tcatch(err) {\n\t\tres.end(\"Withdrawal error: \"  + err.message);\n}  \n```\n\nNote: Exceptions will be catched as expected.\ndb methods (db.select, db.execute) will be called with this=db\n\n\nBasic Usage Example with Express.js\n----\n```\nvar wait = require('wait.for');\nvar express = require('express');\nvar app = express();\n\n// in  a Fiber\nfunction handleGet(req, res){\n  res.send( wait.for(fs.readFile,'largeFile.html') );\n}\n\napp.get('/', function(req,res){\n      wait.launchFiber(handleGet, req, res); //handle in a fiber, keep node spinning\n});\n\napp.listen(3000);\n\n```\n\nGeneric Usage: \n------------\n```javascript\nvar wait=require('wait.for');\n\n// launch a new fiber\nwait.launchFiber(my_seq_function, arg,arg,...)\n\n// fiber\nfunction my_seq_function(arg,arg...){\n    // call async_function(arg1), wait for result, return data\n    var myObj = wait.for(async_function, arg1); \n    // call myObj.querydata(arg1,arg2), wait for result, return data\n    var myObjData = wait.forMethod(myObj,'queryData', arg1, arg2);\n    console.log(myObjData.toString());\n}\n```\n\nParallel Extensions\n----------\n\n-------------\n###wait.parallel.launch(functions:Array)\n     \nNote: must be in a Fiber\n\n####input: \n* functions: Array = [func,arg,arg],[func,arg,arg],...\n\n####actions:\n-launchs a fiber for each func\n-the fiber does `resultArray[index] = func.apply(undefined,args)`\n\n####returns:\n- array with a result for each function\n- do not \"returns\" until all fibers complete\n- throws if error\n\n\n-------------\n###wait.parallel.map(arr:Array, mappedFn:function)\n     \nNote: must be in a Fiber\n\n####input: \n- arr: Array\n- mappedFn = function(item,index,arr) \n-- mappedFn should return converted item. Since we're in a fiber\n-- mappedFn can use wait.for and also throw/try/catch\n        \n####returns:\n- array with converted items\n- do not \"returns\" until all fibers complete\n- throws if error\n\n-------------\n###wait.parallel.filter(arr:Array, itemTestFn:function)\n\nNote: must be in a Fiber\n\n####input: \n- arr: Array\n- itemTestFn = function(item,index,arr) \n-- itemTestFn should return true|false. Since we're in a fiber\n-- itemTestFn can use wait.for and also throw/try/catch\n\n####returns \n- array with items where itemTestFn() returned true\n- do not \"returns\" until all fibers complete\n- throws if error\n\n\n-------------\nParallel Usage Example: \nsee: \n- [parallel-tests](/parallel-tests.js)\n\n-------------\n##Notes on usage on non-standard callbacks. e.g.: connection.query from mysql\n\nwait.for expects standardized callbacks. \nA standardized callback always returns (err,data) in that order.\n\nA solution for the sql.query method and other non-standard callbacks \nis to create a wrapper function standardizing the callback, e.g.:\n\n     connection.prototype.q = function(sql, params, stdCallback){ \n                 this.query(sql,params, function(err,rows,columns){ \n                                     return stdCallback(err,{rows:rows,columns:columns}); \n                             });\n     }\n\nusage:\n\n    try {\n      var result = wait.forMethod(connection, \"q\", options.sql, options.params); \n      console.log(result.rows);\n      console.log(result.columns);\n    } \n    catch(err) {\n       console.log(err);\n    }\n\n",
  "readmeFilename": "README.md",
  "_id": "wait.for@0.6.6",
  "dist": {
    "shasum": "e216c71f6272b64b17f731c9035d3829f2e7984a"
  },
  "_from": "wait.for@",
  "_resolved": "https://registry.npmjs.org/wait.for/-/wait.for-0.6.6.tgz"
}
